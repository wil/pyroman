#Copyright (c) 2006 Erich Schubert erich@debian.org

#Permission is hereby granted, free of charge, to any person obtaining a copy
#of this software and associated documentation files (the "Software"), to deal
#in the Software without restriction, including without limitation the rights
#to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#copies of the Software, and to permit persons to whom the Software is
#furnished to do so, subject to the following conditions:

#The above copyright notice and this permission notice shall be included in
#all copies or substantial portions of the Software.

#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#SOFTWARE.
import sys, socket, signal, re
import config
from util import Util
from iptables import Iptables

class Firewall:
	hostname = socket.gethostname()
	timeout = 30

	class Error(Exception):
		"""
		Basic Exception class
		"""
		pass

	def __init__(self):
		"""
		Create a firewall object. Note that the current code is NOT designed
		to support multiple firewall objects, but refers to the one named
		"firewall" in this file.
		"""
		self.services = {}
		self.hosts = {}
		self.interfaces = {}
		self.nats = []
		self.rules_todo = []
		self.chains = {}

	def append(self, list, cmd, loginfo=None):
		"""
		Append a shell command to one of the lists
		"""
		if not loginfo:
			loginfo = self.get_callee(4)
		cmd = cmd.replace("$ipt",config.iptables).replace("$ipr", config.iproute)
		lines = cmd.splitlines()
		for i in range(0,len(lines)):
			if not Util.ignoreline.match(lines[i]):
				list.append( (lines[i], "%s+%d" % (loginfo, i) ) )

	def append_rule(self, parent, target, filter, table="", loginfo=None):
		"""
		Output an iptables rule with the given parameters.
		The table parameter is optional, just as with iptables.
		"""
		# handle optional table parameter nicely
		if table != "":
			table = " -t " + table
		cmd = "%s%s -A %s %s -j %s" % (config.iptables, table, parent, filter, target )
		self.rules.append( (cmd, loginfo) )

	def verify(self):
		"""
		Verify the data inserted into the firewall
		"""
		for s in self.services.values():
			s.verify()
		for h in self.hosts.values():
			h.verify()
		for i in self.interfaces.values():
			i.verify()
		for r in self.rules_todo:
			r.verify()

	def prepare(self):
		"""
		Prepare for generation run
		"""
		for s in self.services.values():
			s.prepare()
		for h in self.hosts.values():
			h.prepare()
		for i in self.interfaces.values():
			i.prepare()
		for r in self.rules_todo:
			r.prepare()

	def generate(self):
		"""
		Generate the rules from the specifications given
		"""
		self.prepare()
		for r in self.rules_todo:
			r.generate()
		for n in self.nats:
			n.generate()

	def print_rules(self):
		"""
		(Unused, unmaintained code)
		Print the specifications as a shell script, including echo statements
		to explain the lines' origin. Useful for debugging.
		"""
		# collect tables
		tables = []
		for c in self.chains.values():
			if not c.table in tables:
				tables.append(c.table)
		# process tables
		for t in tables:
			print "*%s" % t
			# first create all tables
			for c in self.chains.values():
				if c.table == t:
					c.dump_init()
			# then write rules (which might -j to a table not yet created otherwise)
			for c in self.chains.values():
				if c.table == t:
					c.dump_rules()
			# commit after each table
			print "COMMIT"

	def iptables_save(self):
		"""
		Save current iptables ruleset to a list of lines
		"""
		# save old iptables status
		sr, sw, se = popen3(config.iptablessave)
		sw.close()
		savedlines = sr.readlines()
		sr.close()
		for line in se.readlines():
			sys.stderr.write(line)
		se.close()
		return savedlines

	def iptables_restore(self, savedlines):
		"""
		Restore iptables rules from a list of lines
		(generated by iptables_save)
		"""
		# restore old iptables rules
		ipr = Popen4(config.iptablesrestore)
		rr, rw = ipr.fromchild, ipr.tochild
		for line in savedlines:
			rw.write(line)
		rw.close()
		# output any error
		for line in rr.readlines():
			sys.stderr.write(line)
		rr.close()
		return (ipr.wait() == 0)

	def rollback(self, savedlines):
		"""
		Rollback changes to the firewall, and report rollback success to the user
		"""
		# restore old iptables rules
		restored = Iptables.restore(savedlines)
		if restored:
			sys.stderr.write("*"*70+"\n")
			sys.stderr.write("  FIREWALL ROLLBACK FAILED.\n")
			sys.stderr.write("*"*70+"\n")
		else:
			sys.stderr.write("Firewall initialization failed. Rollback complete.\n")

	def user_confirm_timeout_handler(signum, frame):
		"""
		This handler is called when the user does not confirm
		firewall changes withing the given time limit.
		The firewall will then be rolled back.
		"""
		raise Firewall.Error("Success not confirmed by user")
	user_confirm_timeout_handler = staticmethod(user_confirm_timeout_handler)

	def execute_rules(self):
		"""
		Execute the generated rules
		"""
		sys.stderr.write("Saving old firewall...\n")
		savedlines = Iptables.save()

		sys.stderr.write("*"*70+"\n")
		sys.stderr.write("Beginning firewall initialization...\n")

		# prepare firewall rules
		lines = []
		# collect tables
		tables = []
		for c in self.chains.values():
			if not c.table in tables:
				tables.append(c.table)
		# process tables
		for t in tables:
			lines.append( ["*%s" % t, "Table select statement for table %s" % t] )
			# first create all chains
			for c in self.chains.values():
				if c.table == t:
					lines.append( [c.get_init(), c.loginfo] )
			# then write rules (which might -j to a table not yet created otherwise)
			for c in self.chains.values():
				if c.table == t:
					for l in c.get_rules():
						lines.append(l)
			# commit after each table
			lines.append(["COMMIT", "Commit statement for table %s" % t ])

		# now try to execute the new rules
		successful = False
		try:
			successful = Iptables.commit(lines)
			sys.stderr.write("*"*70+"\n")
			sys.stderr.write("New firewall commited successfully.\n")
			sys.stderr.write("To accept the new configuration, type 'OK' within %d seconds!\n" % Firewall.timeout)
			# setup timeout
			signal.signal(signal.SIGALRM, Firewall.user_confirm_timeout_handler)
			signal.alarm(Firewall.timeout)
			# wait for user input
			input = sys.stdin.readline()
			# reset alarm handling
			signal.alarm(0)
			signal.signal(signal.SIGALRM, signal.SIG_DFL)

			if not re.search("^(OK|YES)", input, re.I):
				raise Firewall.Error("Success not confirmed by user")
		except Iptables.Error, e:
			sys.stderr.write("*"*70+"\n")
			sys.stderr.write("An error occurred. Starting firewall restoration.\n")
			self.rollback(savedlines)
			# show exception
			sys.stderr.write("%s\n" % e);
		except Firewall.Error, e:
			sys.stderr.write("*"*70+"\n")
			sys.stderr.write("An error occurred. Starting firewall restoration.\n")
			self.rollback(savedlines)
			# show exception
			sys.stderr.write("%s\n" % e);
		except:
			sys.stderr.write("*"*70+"\n")
			sys.stderr.write("An error occurred. Starting firewall restoration.\n")
			self.rollback(savedlines)
			sys.stderr.write("\nHere is the exception triggered during execution:\n")
			raise
	

firewall = Firewall()
